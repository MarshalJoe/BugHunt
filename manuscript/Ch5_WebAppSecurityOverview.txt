# Web Application Security Overview

A web application, for the purpose of this guide, is a program stored on a server that responds to requests and/or user input via the Internet. It often (but not always) stores data, connects to external services (like APIs), and performs complex calculations or operations.

## The Ubiquity of Web Apps

Driven by a growing availability and popularity of the tools used to create them, the number of web applications has increased exponentially in recent years. They have become so popular, in fact, that just one, Netflix, was recently found to account for as much as [9.5% of North American upstream traffic](http://arstechnica.com/information-technology/2014/11/netflix-takes-up-9-5-of-upstream-traffic-on-the-north-american-internet/) (coming in as the second biggest consumer of upload bandwidth. The top consumer, if you're curious, is torrent traffic). That's one popular example common to many people's experiences, but whether it's finance, entertainment, or real estate, web applications from search engines to social networks have come to comprise a large part of digital life.

As the number of devices and users connected to the internet increases sharply over the next decade, web applications will become, if possible, more ubiquitous as a way of analyzing and acting upon these large pools of newly-available data. But although the Internet of Things (IoT) promises many things, including new insights harnessed from responsive smart devices, greater security is not one of them. 

## Security Issues Intrinsic to Web Applications

Web applications, as dynamic programs that input and output vast amounts of data, are naturally vulnerable to subversion. Below are some of the security issues that are part and parcel of the way web applications operate.

#### Interconnectedness of Services (APIs)

The explosion of open-source services in the last decade has created a shared template of languages and frameworks that have in turn given rise to a common set of tools, and an ecosystem built around them. The modularity of [APIs](http://en.wikipedia.org/wiki/Application_programming_interface) allows for unparalleled code sharing and developer productivity, as common application functions (geocoding, SMS relays, transactional emails) are abstracted at the community level into everything from javascript libraries to RESTful APIs.

But the pathways to an application necessarily opened by these services can expose web apps to malicious agents. API gateways are an especially prime target because they're often the source of enough traffic to mask attacks. They also often have the ability to access internal data or otherwise make critical state changes inside the app &mdash; an attractive target for malicious users. 

#### The Malice of Users

Web application developers often make the mistake that users won't enter certain commands, or will limit themselves to the direct options made available by the host site's UI, or the constrictions imposed by the browser.

This is simply not the case.

Users may enter the wrong type of data, executable code, or any number of other exotic inputs. They are also liable to using tools that circumvent or otherwise short circuit the browser, programs (like Burp Suite!) that I wholeheartedly suggest you use.

A common mistake is relying on bankrupt concepts like **security through obscurity**. An example of security through obscurity in action would be attaching a click event on a critical button to hide it after activation. There's nothing stopping a (mildly) determined attacker from executing javascript or (in this case) jQuery to the effect of `$(element).show()` or using a proxy that performs that service on every rendered page (like Burp Proxy), then abusing the previously-undetectable button.

From the perspective of web application developers, all incoming data should be treated as malicious. It's difficult in commiting to this philosophy that opens up the door for intrepid pentesting researchers!

#### The Fragmented Nature of Browsers

The main browsers in use today share a remarkable amount of functionality in common. In fact, their (relatively) smooth functioning is a testament to the open-source development of the underlying engines used by, in this case, two of the three most popular browsers in use today (Chrome and Firefox, which share significant portions of essential code). Newer versions of Internet Explorer (IE) and the coming Spartan browser being developed by Microsoft have come a long way in erasing the legacy of mind-numbing boilerplate required by the likes of legacy IE installations.

But different browsers still interact with web applications differently, meaning (for our purposes) that switching things up can sometimes expose varying parts of a web app's attack surface. It's also fruitful, when you're engaging in a pentesting event, to try attacks while toggling through different browser modes. Disabling javascript, for example, can kill the client-side validation mechanisms some poorly-secured apps use to validate their user input. In this instance, running Burp, Websecurify, or whatever other proxy your using under a browser disallowing javascript may highlight these vulnerabilities.